# Malware Analysis: Understanding Virtual Memory and the Portable Executable File Format

### What is a Process and How to the OS Identifies Running Processes

A process can be defined as a running instance of a program. When you click on an .exe file on Windows, the OS loads the
programs data into memory creating a process based on the PE headers defined within the executable file. Creating a process is simple,
here is C program that can be compiled into an exe file:

```
#include <stdio.h>

int main()
{
  while(1);
  return 0;
}
```

Compile with: `gcc -o [outfile_name] [name_of_c_file]`

The C program above, when compiled into a exe file, runs indefinitely, allowing us to analyze the created process by using a process manager
like Process Hacker or Process Explorer. If you run one of these tools and then run the exe file, you should see the creation of a new process named after the exe's name. Using a tool like Process Hacker, you can view information like the parent process ID (PPID), process ID (PID), and
the file path to executable file we launched. Processes can have the same name and have the same source file. The OS does not identify a process
by it's human readable name but rather by it's PID. So say you named your exe file, `test.exe`. You can have several instances of test.exe 
running, but each will be assigned it's own process ID.

After running the exe file and analyzing the process hierarchy displayed in Process Hacker, you should be able to discern the parent process id
that launched our executable file. For example, say you ran the exe file twice from the Windows file explorer, the process hierarchy
would like something like this:

```
- explorer.exe
     - test.exe
     - test.exe
```

This means that parent process ID (PPID) for both the `test.exe` processes is equal to the process ID of the `explorer.exe` file. In Process Hacker, doublie-clicking on any process will open a new window with more information about the process. Two important sections to remember
to look at when analyzing malware is located under the General tab and named **Command-Line** and **Current Directory**. The **Command-Line**
property displays any CLI arguments that were passed into the program. This is crucial when analyzing malware because some malware receive their instructions as program arguments. Malware that is expected to run with parameters may not expose it's true intent until provided
with the correct arguments. Not passing any programs to malware may allow the adversaries to subvert malware analysts and anti-malware
products by disabling it's intentions until the malware has bypassed defenses. The **Current Directory** property tells us the full path
from which the exe file was launched from.

## Virtual Memory

Virtual memory was created to simulate physical RAM using a software-based solution that allows each process running on a system to think
that it has access to an abundant amount of memory that it only has access to. The way this works is that the algorithm used in the virtual
memory allocates space on the physical hard disk or the long term storage device that is used on the system, for example, an SSD. On linux this
allocated space for memory on a hard disk is known as the *swap space* and on Windows it is known as the *page file*. A 32-bit process running
on a 64-bit system can be assigned 4GB of private virtual memory a 64-bit process running on a 64-bit system can technically acquire 8TB
of virtual memory.

**Virtual Addresses**

Virtual memory, just like physical memory, allows a process to access memory via an address. This address is called a *virtual address*.
A process with 4GB's of virtual memory has an address space that starts at address 0 and ends at 2^32-1. Memory addresses are normally viewed
in hexadecimal and thus the address space for a 4GB's of memory in hex is: 0x00000000 to 0xffffffff. 

**Memory Pages**

The virtual memory allocated for a process is further split into smaller chunks that are called *pages*. Depending on the OS being used,
the size of a page in virtual memory varies. To get the page size in Linux, open a terminal and run the command, `getconf PAGE_SIZE`. On
Windows, you can obtain the page size by following this [tutorial](https://www.geeksinphoenix.com/blog/post/2016/05/10/how-to-manage-windows-10-virtual-memory.aspx). Physical memory has its own type of page known as a *frame*.

The pages in virtual memory are loaded into physical memory when they are being used. The other pages of virtual memory that are needed for
a process but are not currently being utilized are stored in the systems storage disk, allowing other processes to place their
virtual memory pages in physical memory to execute instructions. This process of swapping out pages between physical memory and the hard disk
is known as *Demand Paging*. This is effectively how physical memory avoids becoming unavailable to other processes because one process is
consuming all of the physical memory and instead allows for many processes to use physical memory simultaneously.

**Page Tables**

For the CPU to execute instructions of a running process, it must be capable of mapping a processes virtual addresses to their
actual physical addresses because the CPU only executes instructions that reside in the physical memory of a computer and not the virtual
memory of a process. In order to make this conversion of addresses the operating system uses a page table. A Page Table is responsible for
convertinng a virtual address into a physical address that resides in physical memory.

**Windows Memory Spaces**

In a 32-bit Windows OS, each process is assigned 4GBs of virtual memory that ranges from 0x00000000 to 0xffffffff. But Windows divides this
address range into two memory space: the user space and the kernal space. The user space ranges from 0x00000000 to 0x7fffffff and the kernel
space ranges from 0x80000000 to 0xffffffff. The user space for each process running on a system is different, meaning the data and instructions,
residing in the user space differs for each process. The kernel space however is shared across all of the running processes.

**Page Analysis**

We can view information about a processes virtual memory pages using tools like Process Hacker and Process Explorer. Using Process Hacker,
double-click on a running process and go to the **memory** to see information about that processes virtual memory pages. This will show you
things like page permissions, the address of the page, and the size of the page. 

The memory tab has a column named **Type** which specifies a page's type which can be any of the three following values: `private`, `image`,
or `mapped`. A page that is of type `private` means the is not shared with any other running process; a page of type `image` means that the
page is storing the modules of the main executable file and all of its DLLs; a page of type `mapped` means the page is responsible for mapping
files on disk into virtual memory that the process is using. 

Looking at the same column in the memory tab called **Type** you can also see the state of the page. There are also three possible stages that
a page can be in: `reserved`, `committed`, or `free`. If a page is in a `reserved` state, the page has been allocated in virtual
memory but does not have a mapping to physical memory. If a page is in a `commited` state, the page is no longer just allocated in virtual
memory but it also has a mapping to physical addresses in physical memory. And finally is a page is in a `free` state, the address range for
that page has not assigned or has not become available to the process.

Pages can also be assigned permissions. Pages can have read, write, and/or execute permissions:
- If the page has the read bit set, the pages contents can read
- If the page has the write bit set, the page can be read and written into
- If the page has the execute bit set, the page is executable

Microsoft's Data Execution Prevention (DEP) was created to ensure that pages allocated on the stack do not have execute permissions.

**Virtual Memory and Malware**

Malware that is encrypted or packed at some point needs to decipher itself for the CPU to execute its instruction and because of this we
can analyze the virtual memory of malware and see the decrypted malware code and other pieces of information that can be utilized to classify
that malware. Understanding virtual memory pages also malware analysts to analyze malware that performs its techniques in its virtual memory 
or the virtual memory of another process. 

## The PE File Format

The PE file format assists the Windows loader in loading an exe file into memory, turning it into a running process.
