# Malware Analysis: Understanding Virtual Memory and the Portable Executable File Format

### Processes

A process can be defined as a running instance of a program. When you click on an .exe file on Windows, the OS loads the
programs data into memory creating a process based on the PE headers defined within the executable file. Creating a process is simple,
here is C program that can be compiled into an exe file:

```
#include <stdio.h>

int main()
{
  while(1);
  return 0;
}
```

Compile with: `gcc -o [outfile_name] [name_of_c_file]`

The C program above, when compiled into a exe file, runs indefinitely, allowing us to analyze the created process by using a process manager
like Process Hacker or Process Explorer. If you run one of these tools and then run the exe file, you should see the creation of a new process named after the exe's name. Using a tool like Process Hacker, you can view information like the parent process ID (PPID), process ID (PID), and
the file path to executable file we launched. Processes can have the same name and have the same source file. The OS does not identify a process
by it's human readable name but rather by it's PID. So say you named your exe file, `test.exe`. You can have several instances of test.exe 
running, but each will be assigned it's own process ID.

After running the exe file and analyzing the process hierarchy displayed in Process Hacker, you should be able to discern the parent process id
that launched our executable file. For example, say you ran the exe file twice from the Windows file explorer, the process hierarchy
would like something like this:

```
- explorer.exe
     - test.exe
     - test.exe
```

This means that parent process ID (PPID) for both the `test.exe` processes is equal to the process ID of the `explorer.exe` file. In Process Hacker, doublie-clicking on any process will open a new window with more information about the process. Two important sections to remember
to look at when analyzing malware is located under the General tab and named **Command-Line** and **Current Directory**. The **Command-Line**
property displays any CLI arguments that were passed into the program. This is crucial when analyzing malware because some malware receive their instructions as program arguments. Malware that is expected to run with parameters may not expose it's true intent until provided
with the correct arguments. Not passing any programs to malware may allow the adversaries to subvert malware analysts and anti-malware
products by disabling it's intentions until the malware has bypassed defenses. The **Current Directory** property tells us the full path
from which the exe file was launched from.

## Virtual Memory

Virtual memory was created to simulate physical RAM using a software-based solution that allows each process running on a system to think
that it has access to an abundant amount of memory that it only has access to. The way this works is that the algorithm used in the virtual
memory allocates space on the physical hard disk or the long term storage device that is used on the system, for example, an SSD. On linux this
allocated space for memory on a hard disk is known as the *swap space* and on Windows it is known as the *page file*. A 32-bit process running
on a 64-bit system can be assigned 4GB of private virtual memory a 64-bit process running on a 64-bit system can technically acquire 8TB
of virtual memory.

**Virtual Addresses**

Virtual memory, just like physical memory, allows a process to access memory via an address. This address is called a *virtual address*.
A process with 4GB's of virtual memory has an address space that starts at address 0 and ends at 2^32-1. Memory addresses are normally viewed
in hexadecimal and thus the address space for a 4GB's of memory in hex is: 0x00000000 to 0xffffffff. 

**Memory Pages**

The virtual memory allocated for a process is further split into smaller chunks that are called *pages*. Depending on the OS being used,
the size of a page in virtual memory varies. To get the page size in Linux, open a terminal and run the command, `getconf PAGE_SIZE`. On
Windows, you can obtain the page size by following this [tutorial](https://www.geeksinphoenix.com/blog/post/2016/05/10/how-to-manage-windows-10-virtual-memory.aspx). Physical memory has its own type of page known as a *frame*.

The pages in virtual memory are loaded into physical memory when they are being used. The other pages of virtual memory that are needed for
a process but are not currently being utilized are stored in the systems storage disk, allowing other processes to place their
virtual memory pages in physical memory to execute instructions. This process of swapping out pages between physical memory and the hard disk
is known as *Demand Paging*. This is effectively how physical memory avoids becoming unavailable to other processes because one process is
consuming all of the physical memory and instead allows for many processes to use physical memory simultaneously.

**Page Tables**

For the CPU to execute instructions of a running process, it must be capable of mapping a processes virtual addresses to their
actual physical addresses because the CPU only executes instructions that reside in the physical memory of a computer and not the virtual
memory of a process. In order to make this conversion of addresses the operating system uses a page table. A Page Table is responsible for
convertinng a virtual address into a physical address that resides in physical memory.

**Windows Memory Spaces**

In a 32-bit Windows OS, each process is assigned 4GBs of virtual memory that ranges from 0x00000000 to 0xffffffff. But Windows divides this
address range into two memory space: the user space and the kernal space. The user space ranges from 0x00000000 to 0x7fffffff and the kernel
space ranges from 0x80000000 to 0xffffffff. The user space for each process running on a system is different, meaning the data and instructions,
residing in the user space differs for each process. The kernel space however is shared across all of the running processes.

**Page Analysis**

We can view information about a processes virtual memory pages using tools like Process Hacker and Process Explorer. Using Process Hacker,
double-click on a running process and go to the **memory** to see information about that processes virtual memory pages. This will show you
things like page permissions, the address of the page, and the size of the page. 

The memory tab has a column named **Type** which specifies a page's type which can be any of the three following values: `private`, `image`,
or `mapped`. A page that is of type `private` means the is not shared with any other running process; a page of type `image` means that the
page is storing the modules of the main executable file and all of its DLLs; a page of type `mapped` means the page is responsible for mapping
files on disk into virtual memory that the process is using. 

Looking at the same column in the memory tab called **Type** you can also see the state of the page. There are also three possible stages that
a page can be in: `reserved`, `committed`, or `free`. If a page is in a `reserved` state, the page has been allocated in virtual
memory but does not have a mapping to physical memory. If a page is in a `commited` state, the page is no longer just allocated in virtual
memory but it also has a mapping to physical addresses in physical memory. And finally is a page is in a `free` state, the address range for
that page has not assigned or has not become available to the process.

Pages can also be assigned permissions. Pages can have read, write, and/or execute permissions:
- If the page has the read bit set, the pages contents can read
- If the page has the write bit set, the page can be read and written into
- If the page has the execute bit set, the page is executable

Microsoft's Data Execution Prevention (DEP) was created to ensure that pages allocated on the stack do not have execute permissions.

**Virtual Memory and Malware**

Malware that is encrypted or packed at some point needs to decipher itself for the CPU to execute its instruction and because of this we
can analyze the virtual memory of malware and see the decrypted malware code and other pieces of information that can be utilized to classify
that malware. Understanding virtual memory pages also malware analysts to analyze malware that performs its techniques in its virtual memory 
or the virtual memory of another process. 

## The PE File Format

The PE file format assists the Windows loader in loading an exe file from disk into memory, turning it into a process. The file format for
a Windows executable file is the portable EXE (PE) file format. All the code, data, and resources that a PE file is dependent on, is
defined in specific headers within the PE file itself. Within these headers, the Windows loader can find information on how much virtual
memory is needed when launching the process and how to store the various components of the executable file. All PE files, when visualized
with a hexeditor, start with the magic bytes, `4d 5a` (MZ), the MZ DOS header. PE files are not always strictly executable, they can also be
Dynamic Link Library (.dll) or system files (.sys). A tool like CFF explorer can be to parse the many headers of a PE file.


**Windows Executables**

A PE file is composed of two components: headers and sections. The headers store metadata and the sections store the actually program code,
data, and the resources that code is dependent on. The metadata that can be stored in the PE headers are things like when the file was
created, modified, last accessed, PE version, size of the file, etc. Below is image showing the CFF explorer output after parsing an
exe file. The image shows most of the DOS header fields and their corresponding offsets, size, and values. The first value `e_magic` 
shows the magic bytes for the PE file: `5A4D`. The order of the magic bytes diplayed in CFF explorer is in little-endian for so the 
least significant bit is stored at a lower memory address. 

![cff_explorere](/MalwareAnalysis/images/cff_explorer_dos_header.png)

**Image Base**

The Windows loader loads a programs into memory by copying the PE file on disk into the virtual memory that has been allocated for
the process. The Windows loader allocates virtual memory space by retrieving the value under the Optional Header called the ImageBase.
The value for the ImageBase field defines where in virtual memory the Windows loader should begin to allocate space for loading the PE file.
The Windows loader, however, doesn't always allocate the space for the PE file in the virtual address specified by the ImageBase because
it is likely the virtual address has already been occupied with other contents and thus the loader can't use the address to load the PE file
into. The loader doesn't attempt to move the contents that are being stored at the specified ImageBase address but rather it finds another
place in virtual memory where this is empty space, allocates some space there, and then copies the PE file and all of its data into the 
allocated space. This means that the original ImageBase field in the PE file gets updated automatically with the address that the loader
chose for storing the PE file and its contents.

**Relative Virtual Addresses (RVA)**

Just as there is an ImageBase field in the PE file header that tells the loader where to load the PE file and its contents, there are also
other fields in the PE file header that specify the virtual address for other points of data within the file. As we learned in the previous
section, the address of the ImageBase is just a recommendation for the loader so the loader might not always load the PE file into the 
the ImageBase address and therefore, all other fields that relied on an absolute address to the ImageBase now have to use what is known
as *Relative Virtual Addresses* (RVA). Using RVA, the values for the fields within the PE file use offsets to the base address.
For example, say the loader ignored the image base address because it was being used, and allocated the PE file into the address `0x200000`.
All fields that used absolute addresses to the original ImageBase can no longer reference the same virtual address and thus must use RVA
to obtain offsets to the address chosen by the loader. If a field intended to access a value at `0x200020`, the value for the field will
be set to the offset, `0x20`. All fields now specify these offset to the base address. 

Within the **Optional Header** section of a PE file, you can find verify the field `AddressOfEntryPoint`. This field tells us the offset to
the first instruction that the CPU will execute in the process. We can open up OllyDbg to verify to verify RVA. The image belows shows both
CFF explorer and OllyDbg interfaces. By loading the exe into CFF explorer, we can see the value for the `ImageBase` is `0x00400000` and
the value for the `AddressOfEntryPoint` is `0x00001040`. This means that virtual address of the first instruction that will be executed
should be at `0x400000` + `0x1040` = `0x401040`. We confirm this by opening the same exe file into OllyDbg, and seeing that when it finishes
loading the first instruction ready to execute is at the expected address of `0x00401040`:

![cff_and_olly_rva](/MalwareAnalysis/images/cff_and_olly_rva.png)

**PE Headers and Fields**

A PE header consists of three main headers: DOS headers, NT headers, and section headers. Other subheaders may exists within these three main
headers. All headers and subheaders are composed of many fields that stores various pieces of information regarding the PE file.

- DOS Header
  - the DOS header is the first header found in a PE file and its most important field would be the `e_magic` which defines the magic bytes
  for the PE file, `4d5a`. There are other fields, for example, like `e_lfanew` which defines the offset from the start of the file to the
  start of the NT header.
  
- NT Header 
  - the NT header is composed of two other subheaders: File header and the Optional header. The NT header contains one field called
  `Signature` and it stores the value `0x5045`. This identifies the file as a PE format image file.
  
  - File Header:
    - the File Header has a total of 7 fields, but most important for malware analsyts to understand are the `Machine`, `NumberOfSections`, and `Characteristics` fields.
    - the `Machine` field specifies on which process type (x86, 0x64, ARM, MIPS, etc) a PE file was compiled to run on.
    - the `NumberOfSections` field tells us how many sections are present in the PE file. Knowing this value can help malware analysts determine is an adversary has added malicous sections to the PE file. Adversaries would normally also modify this value to reflect the number of sections in the PE file.
    - the `Characteristics` field consists of a 2-byte bit field value that describes many properties of the PE FILE such as whether the file is an executable file, or if its a DLL. It also defines whether this PE file is a 32-bit or 64-bit executable file.
    
  - Optional Header:
    - the Optional Header contains many of the fields that the Windows loader relies on to correctly load the PE file into the process's virtual memory.
    - the `ImageBase` defined in the Optional Header tells the Windows loader on where it should load the PE file in virtual memory.
    - the `AddressofEntryPoint` also defined in the Optional Header informs that loader of the first address with instructions it should execute.
    - Data Directory
      - The Data Directory subheader contains information on the size and relative virtual address (RVA) of data/tables/directories. If the directory doesn't exist in memory, the RVA and size of that directory will be 0.
    
- Section Header
  - Sections contain the code, data that is used by import, export, and other tables. Sections are loaded into virtual memory by the loader and the Section Header has information on how the PE file is stored in nonvolatile memory and in virtual memory. This information includes how much memory should be allocated for each each section, the permissions that should be set on pages created for each section, and the name of the section.
  - each section contains the following important fields:
    - `Name`: the sections name
    - `Virtual Address`: the RVA for the section in virtual memory
    - `Raw Size`: the size of the section data in PE file in nonvolatile memory
    - `Raw Address`: the offset from the start of the PE file to start of the sections data
    - `Characteristics`: general properties of the section (is it executable?, does it contain code?, is it shareable?)

**Windows Loader: Section Data**

Using the `Raw Address` and `Raw Size` values defined for each section, the loader reads the section from nonvolatile memory and copies it
into virtual memory. The `Raw Size` does not defined how much space we'll be allocated in virtual memory. The amount of space allocated is
defined by the `Virtual Size` field also defined for each section. The actual address of a section will be the `ImageBase` + `Virtual Address`.

**Dynamic-Link Library (DLL)**

DLLs are shared libraries. They contain functions called APIs that other executable programs can import and use. On Windows, a DLL file has the file extension, `.dll`. DLLs also use PE file format for structing its contents. DLLs contains executable code but cannot be ran as it's
process in memory as an `.exe` file can. It's contents on get loaded into memory and executed when another executable program invokes it
from its virtual memory. The `Characteristics` field can tell us whether a file is a DLL or not. Loading a file into CFF explorer and 
navigating to `NT Header` > `File Header` and clicking on the `Meaning` column for the `Characteristics` field, informs us if the file
is a DLL by showing a checkmark next to the sentence, `File is a DLL`:

![cff_is_file_dll](/MalwareAnalsys/images/cff_is_file_dll.png)

